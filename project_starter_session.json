{
  "name": "Balls",
  "parent_folder": "C:\\Users\\miche\\Desktop",
  "stack": "NodeJS",
  "description": "Particles made up out of various sized spheres in a pleasing color pallette, drifting on the screen",
  "goal": "I want to build...\n\nParticles made up out of various sized spheres in a pleasing color pallette, drifting on the screen",
  "concept_md": "# Project Concept: Interactive Particle Drift\n\nA lightweight, generative art web app for general users to experience visual relaxation and playful interaction. The app allows users to interact with a field of drifting geometric particles with responsive physics. This is designed as a local single-page web application for a single user.\n\n---\n\n## Core Principles\n\n- **Visual Harmony:** The aesthetic focuses on a curated, pleasing color palette and smooth geometric shapes (spheres) to create a calming visual environment.\n- **Organic Physics:** Interactions between the cursor and particles should feel fluid and weightless, simulating a sensation of floating rather than rigid mechanical collision.\n- **Performance First:** The simulation must maintain a high frame rate (60fps) to ensure the sense of immersion is not broken by lag, even with numerous particles onscreen.\n\n## Key Features\n\n### Feature A: Ambient Particle Simulation\n- **Purpose:** To create a dynamic background of drifting spheres with varying radii and colors.\n- **Mechanics:** Upon load, the application generates a set number of spherical particles. Each particle is assigned a random size, a color from a pre-defined harmonious palette, and an initial velocity vector. They drift across the canvas, bouncing gently off the viewport edges.\n\n### Feature B: Cursor Force Field\n- **Purpose:** To allow the user to manipulate the simulation directly.\n- **Mechanics:** The mouse cursor generates an invisible radial force field. As the cursor moves near particles, they are either repelled away or attracted (depending on configuration), creating a \"wake\" effect through the field of spheres. The closer the cursor is to a particle, the stronger the force applied.\n\n---\n\n## User Actions\n\n- **Mouse Hover / Move:** The primary interaction. Any user moving their cursor over the canvas will influence the trajectory of nearby particles based on the physics engine's repulsion/attraction settings.\n- **Mouse Click:** Users can click the canvas to emit a \"shockwave\" or stronger impulse, scattering particles outward from the click location with higher velocity.\n- **Window Resize:** When the user resizes their browser window, the canvas automatically adjusts its dimensions, and particles are re-bounded to stay within the new viewable area.\n\n---\n\n## Data Synchronization Strategy\n\n- **Source of Truth:** The **Client** (specifically the browser's local memory) is the single source of truth. There is no server-side state.\n- **Data Flow:** Data flow is strictly internal to the application via the `requestAnimationFrame` loop. The physics engine calculates positions based on current velocity and cursor inputs, then renders the frame to the HTML5 Canvas or WebGL context.\n- **Conflict Resolution:** Not applicable. As a purely local, single-user experience, there are no concurrent data modification conflicts to resolve.",
  "todo_md": "# Project Bootstrap TODO\n\nThis plan outlines the phases for building out the \"Interactive Particle Drift\" project, from initial setup to a deployable application.\n\n## Phase 1: Environment Setup & Core Connection\n**Goal:** A working local environment is established, with the basic HTML5 Canvas structure and main loop operational.\n\n- [ ] **Data Structure Design:** Set up the initial state schema based on `concept.md`.\n  - [ ] Define the `Particle` class/object structure (properties: `x`, `y`, `vx`, `vy`, `radius`, `color`).\n  - [ ] Initialize the global array to hold particle instances (the \"Source of Truth\").\n  - [ ] Define the configuration object for physics constants (friction, speed limits, count).\n- [ ] **Core Loop:** Implement the animation scaffolding.\n  - [ ] Create the `requestAnimationFrame` loop to handle the continuous update cycle.\n  - [ ] Create empty `update()` and `draw()` functions to be called within the loop.\n- [ ] **Frontend:** Connect the logic to the DOM.\n  - [ ] Set up `index.html` with a full-screen `<canvas>` element.\n  - [ ] Implement a basic initialization script to resize the canvas to the window inner dimensions.\n- [ ] **Testing Point 1: Verify Core Connection**\n  - [ ] Open `index.html` in a local browser.\n  - [ ] Check the console to confirm the `requestAnimationFrame` loop is firing continuously.\n  - [ ] Verify the canvas element covers the viewport.\n\n## Phase 2: Core Feature UI & Data Display\n**Goal:** The canvas renders the static visual elements (Feature A: Ambient Particle Simulation - Visuals).\n\n- [ ] **UI Development:** Implement the rendering logic.\n  - [ ] Implement the `draw()` method to clear the canvas frame.\n  - [ ] Implement the logic to render a single sphere (circle) based on the `Particle` properties.\n- [ ] **Data Display:** Populate the simulation with initial data.\n  - [ ] Implement a \"harmonious color palette\" generator or array selection.\n  - [ ] Create a generator function to populate the particle array with random positions, radii, and initial velocities upon load.\n- [ ] **Testing Point 2: Verify UI & Data Rendering**\n  - [ ] Refresh the browser.\n  - [ ] Confirm the screen is populated with static spheres of varying sizes and harmonious colors.\n  - [ ] Verify particles are spawned within the visible bounds of the screen.\n\n## Phase 3: Core Logic & User Actions\n**Goal:** Application physics are implemented, allowing ambient movement and user interaction (Feature B & User Actions).\n\n- [ ] **Physics Logic:** Implement the ambient movement (CRUD - Update).\n  - [ ] Update `Particle` positions based on velocity vectors in the `update()` loop.\n  - [ ] Implement boundary collision detection to make particles \"bounce gently\" off viewport edges.\n- [ ] **Frontend:** Implement user interaction flows.\n  - [ ] Add an event listener for `mousemove` to track cursor coordinates.\n  - [ ] Implement Feature B: Calculate distance between cursor and particles to apply radial force (repulsion/attraction).\n  - [ ] Add an event listener for `click` to trigger the \"Shockwave\" impulse logic.\n- [ ] **Data & Sync Logic:** Optimize the simulation loop.\n  - [ ] Ensure logic updates are decoupled from frame rate if necessary (delta time), or strictly bound to `requestAnimationFrame` for simplicity.\n  - [ ] Optimize loop for performance (e.g., avoid object creation inside the loop) to target 60fps.\n- [ ] **Testing Point 3: Verify End-to-End User Actions**\n  - [ ] specific test: Watch particles drift and bounce off walls automatically.\n  - [ ] specific test: Move mouse through the field and verify particles part ways (wake effect).\n  - [ ] specific test: Click the canvas and verify particles scatter outward from the click point.\n\n## Phase 4: Automation & Polishing\n**Goal:** Automated responsiveness is implemented and the visual experience is tuned for relaxation.\n\n- [ ] **Automation:** Implement responsive layout handling.\n  - [ ] Add a `resize` event listener to update canvas dimensions dynamically.\n  - [ ] Implement logic to re-bound or shift particles that fall outside the new dimensions during a resize.\n- [ ] **Frontend/UI:** Refine the visual and physical experience.\n  - [ ] Tune physics variables (friction, restitution, max velocity) to ensure the \"fluid and weightless\" feel.\n  - [ ] Polish the visual rendering (e.g., adding slight opacity or gradients to spheres).\n  - [ ] Ensure the color palette provides sufficient contrast and visual harmony.\n- [ ] **Testing Point 4: Verify Automation and Polish**\n  - [ ] Resize the browser window drastically and confirm no particles are lost or distorted.\n  - [ ] Check for visual jitter or lag with a high particle count.\n  - [ ] Verify the aesthetic feel matches the \"Visual Harmony\" principle.\n\n## Phase 5: Deployment\n**Goal:** The application is packaged and deployed as a static web page.\n\n- [ ] **Frontend:** Package the application for production.\n  - [ ] Minify CSS and JavaScript files for faster load times.\n  - [ ] Ensure assets (if any) are optimized.\n- [ ] **Backend:** (Not Applicable - Client-Side Only).\n  - [ ] Verify no lingering references to local debug tools exist in the code.\n- [ ] **Deployment:** Deploy the application.\n  - [ ] Push code to a repository (e.g., GitHub).\n  - [ ] Connect repository to a static hosting provider (e.g., GitHub Pages, Vercel, or Netlify).\n- [ ] **Post-Deployment Testing:**\n  - [ ] Access the live URL on a desktop browser.\n  - [ ] Verify 60fps performance and touch/mouse responsiveness in the production environment.\n\n## Future Enhancements\n- [ ] Add touch support for mobile devices (tap for shockwave, drag for wake).\n- [ ] Add a control panel UI for users to adjust gravity, friction, or particle count in real-time.\n- [ ] Implement audio reactivity where particles pulse to a music beat."
}